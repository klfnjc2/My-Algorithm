[LCR 126. 斐波那契数](https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/)

简单



**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 **0** 和 **1** 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给定 `n` ，请计算 `F(n)` 。

答案需要取模 1e9+7(1000000007) ，如计算初始结果为：1000000008，请返回 1。

 

**示例 1：**

```
输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
```

**示例 2：**

```
输入：n = 3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2
```

**示例 3：**

```
输入：n = 4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3
```

 

**提示：**

- `0 <= n <= 100`



**题解1:** 使用斐波那契公式递归的解决问题(超时)

```c++
class Solution {
public:
    int fib(int n) {
        if(n<2)
            return n;
        else
            return fib(n-1)+fib(n-2);
    }
};
```



**题解2:** 使用滚动数组解决问题
滚动数组是一种能降低空间复杂度的方法,具体来说,我们观察那那些是`需要使用的数据`那些是 `可以抛弃的数据`,用新的数据不断覆盖旧的数据以减少空间的使用.
在本题中得到第三位的值需要第一位的值与第二位的值相加,在得到第三位的值后第一位的值将不会再被使用到,也就是`可以抛弃的数据`
我们便可以将第四位的值存放在第一位上,循环往复即可解决问题

```c++
class Solution {
public:
    int fib(int n) {
        if(n<2)
            return n;
        int MOD = 1000000007;//由于精度问题,结果%MOD
        int F[3],j=1;
        F[0]=F[1]=1;
        for(int i=2;i<n;i++){//通过循环遍历数组达到数组滚动的目的
            j=(j+1)%3;//数组循环便利公式 下标=(下标+1)%数组大小
            F[j]=(F[(j+1)%3]+F[((j+1)%3+1)%3])%MOD;
        }
        return F[j];
    }
};
```

**优化题解2:** 使用变量来代替数组,省去了循环遍历数组,更加简洁,提高可读性

```c++
class Solution {
public:
    int fib(int n) {
        if(n<2)
            return n;
        int MOD = 1000000007;//由于精度问题,结果%MOD
        int a=0,b=1,c;
        for(int i=2;i<=n;i++){//通过循环遍历数组达到数组滚动的目的
            c=(a+b)%MOD;
            a=b;
            b=c;
        }
        return c;
    }
};
```

